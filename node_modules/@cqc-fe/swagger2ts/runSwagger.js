#!/usr/bin/env node

const path = require('path');
const fs = require('fs');
const fsPromises = fs.promises;
const { fsExistsSync, throwNewError } = require('./utils');
const { generateApi } = require('@cqc-fe/swagger-typescript-api-self');

// 执行swagger.config文件的生成
const runSwagger = async (options) => {
  // 判断swagger.config.js文件是否存在
  if (!fsExistsSync(path.resolve('swagger.config.js'))) {
    // 不存在的时候就要往项目中注入swagger.config.js，并执行runGen
    try {
      const data = await fsPromises.readFile(path.resolve(__dirname, 'swaggerTemplate.js'), { encoding: 'utf8' });
      const newData = data.replace(/swaggerUrl/g, options.path ? options.path : '')
      await fsPromises.writeFile('swagger.config.js', newData)
      if (!options.path) return;
      runGen()
    } catch (error) {
      throwNewError(error)
    }
  } else {
    // 存在swagger.config.js，执行runGen
    if (options.path) {
      throwNewError('已存在swagger.config.js，请在该js中修改url地址');
    } else {
      runGen()
    }
  }
}

// 执行api文件生成过程
const runGen = async () => {
  const config = require(path.resolve('swagger.config.js'))
  const customFlag = config.modular
  if (config.url === 'swaggerUrl' || config.url === '') {
    throwNewError('请在swagger.config.js中填写url');
    return;
  }
  let newConfig = {
    // 是否将api.ts中请求参数的数据类型提取出来
    extractRequestParams: true,
    // 是否将api.ts中请求参数的requestbody的数据类型提取出来
    extractRequestBody: true,
    // 是否将枚举值提取出来
    extractEnums: true,
    //是否直接返回响应数据的reponse.data
    unwrapResponseData: true,
    ...config,
    output: path.resolve(config.output),
    templates: customFlag ? path.resolve(__dirname, "template") : config.templates,
    moduleNameFirstTag: customFlag ? true : config.moduleNameFirstTag,
    extraTemplates: customFlag ? [
      {
        name: "http-client-types",
        path: path.resolve(__dirname, "./template/http-clients/http-client-types.ejs")
      },
    ] : []
  }
  const res = await generateApi(newConfig);
}

module.exports = runSwagger;