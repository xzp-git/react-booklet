# swagger2ts

基于swagger-typescript-api，在保留原来所有功能的情况下，内置定制模板，通过swagger方案生成api详细模块。与swagger-typescript-api相比，拓展了以下功能：

1. install后，只需要在package.json添加xxx: "gen-swagger"命令并执行，即可自动会根据swagger.json地址使用内置模板生成api模块，并会在项目根目录生成swagger.config.js文件进行所需功能的配置，降低团队开发人员使用成本，生成最适合项目的api模块。swagger.config.js已经内置了swagger-typescript-js的基础功能。
2. 输出文件细致化，支持自定义修改的http-client.ts文件依然保留，解决每次生成过程，该文件会被覆盖的情况。
3. 完善axios以及fetch请求方法，添加请求拦截器、响应拦截器、错误捕获处理等功能。
4. 输出的api方法由promise改为async await形式。

## Update Version Log
```
1.0.4
1、修改递归生成爆栈问题
```

## 安装及使用

### step 1

```
yarn add @cqc-fe/swagger2ts
```

### step2

```
package.json中添加xxx: "gen-swagger -s"
```
### step3

```
初次使用，执行 npm run xxx -p swagger.json地址，初始化swagger。
更新，请直接执行npm run xxx即可。
```

## swagger.config.js 配置文件说明

支持swagger-typescript-api所有的api

```
{
// 当使用module:false，单文件输出形式的文件命名
name: "MySuperbApi.ts",
// 文件输出路径
output:  './src/__generated__',	
// swagger.json文件地址
url: 'http://api.com/swagger.json',	
// 或者不用线上地址形式，本地导入foo/swagger.json
input: path.resolve(process.cwd(), './foo/swagger.json'),
// 描述
spec: {
	swagger: "2.0",
	info: {
		version: "1.0.0",
		title: "Swagger Petstore",
	},
},
// 自定义模板路径，传入该属性则不会使用内置定制模板
templates: path.resolve(process.cwd(), './api-templates'),
// 使用内置定制模板，false则为不使用
useDefaultTemplate: true,  （🚀️ 新增）
// 选择使用哪种请求方式
httpClientType: "axios", // or "fetch",
defaultResponseAsSuccess: false,
// 是否输出http-client相关文件
generateClient: true,
// 是否输出api的routeType.ts文件
generateRouteTypes: false,
// 在api文件中是否生成响应信息注释
generateResponses: true,
// 是否将api.ts转成api.js输出
toJS: false,
// 是否将api.ts中请求参数的数据类型提取出来
extractRequestParams: false,
// 是否将api.ts中请求参数的requestbody的数据类型提取出来
extractRequestBody: false,
// 是否将枚举值提取出来
extractEnums: false,
//是否直接返回响应数据的reponse.data
unwrapResponseData: false,
// 定制输出文件的preitter规则
prettier: { 
printWidth: 120,
tabWidth: 2,
trailingComma: "all",
parser: "typescript",
},
// 默认返回的响应数据类型
defaultResponseType: "void",
// 能够将HttpClient实例发送到Api构造函数，默认为false
singleHttpClient: false,
// 是否在每次生成文件之前都清空output文件
cleanOutput: false,
enumNamesAsValues: false,
// 是否将api模块化
moduleNameFirstTag: false,
// 将所有“enum”类型生成为并集类型（T1|T2|TN）（默认值：false）
generateUnionEnums: false,
// 自定义数据类型加上前缀
typePrefix: '',
// 自定义数据类型加上后缀
typeSuffix: '',
// 自定义枚举前缀
enumKeyPrefix: '',
// 自定义枚举后缀
enumKeySuffix: '',
// 生成只读属性（默认值：false）
addReadonly: false,
// 提取选项
extractingOptions: {
	requestBodySuffix: ["Payload", "Body", "Input"],
	requestParamsSuffix: ["Params"],
	responseBodySuffix: ["Data", "Result", "Output"],
	responseErrorSuffix: ["Error", "Fail", "Fails", "ErrorData", "HttpError", "BadResponse"],
},
// 允许自定义ejs模板并输出
extraTemplates: [],
// 是否将定义数组类型从 xxx[]变成Array<xxxx>
anotherArrayType: false,
fixInvalidTypeNamePrefix: "Type",
fixInvalidEnumKeyPrefix: "Value",
// 可修改数据类型转换
codeGenConstructs: (constructs) => ({
...constructs,
RecordType: (key, value) => `MyRecord`
}),
// 类型映射器，可以转换数据类型
primitiveTypeConstructs: (constructs) => ({
	...constructs,
	string: {
	'date-time': 'Date'
	}
}),
// 生命周期钩子，hooks
hooks: {
	onCreateComponent: (component) => {},
	onCreateRequestParams: (rawType) => {},
	onCreateRoute: (routeData) => {},
	onCreateRouteName: (routeNameInfo, rawRouteInfo) => {},
	onFormatRouteName: (routeInfo, templateRouteName) => {},
	onFormatTypeName: (typeName, rawTypeName, schemaType) => {},
	onInit: (configuration) => {},
	onPreParseSchema: (originalSchema, typeName, schemaType) => {},
	onParseSchema: (originalSchema, parsedSchema) => {},
	onPrepareConfig: (currentConfiguration) => {},
	}
}
```






